                      Mini-projet 1 : solveur DPLL récursif
                             fichier RENDU
                       

********** à remplir obligatoirement **********

**Un mini-projet sans fichier RENDU rempli ne recevra pas de note.**

Date limite: le vendredi 25 octobre 2024 à 19:00

Identité
--------
Nombre de binôme: 34
Nom, prénom 1: Aouini Radouane 
Nom, prénom 2: Chioukh Sami


Questions sur votre code
------------------------
0. Avez-vous testé que `make dpll` s'exécute sans erreurs ou warnings,
   et que ensuite `./dpll sudoku-4x4.cnf` donne la réponse attendue (voir
   fichier README) ?

Oui, on a testé que make dpll s'exécute sans erreurs ou warnings. On a également exécuté ./dpll sudoku-4x4.cnf, et cela nous a donné la réponse attendue conformément aux indications du fichier README.

---

1. Avez-vous utilisé la fonction `filter_map` (donné dans dpll.ml)
   dans votre implémentation de `simplifie` ? 
   - Si oui, expliquez en quelques phrases en français comment vous
     l'avez utilisée.
   - Si non, expliquez en quelques phrases en français comment
     fonctionne votre implémentation de `simplifie`.

Oui, on a utilisé la fonction filter_map dans mon implémentation de la fonction simplifie. On l'a utilisée pour appliquer la simplification en filtrant et en modifiant les clauses à l'aide de la fonction aux. La fonction aux construit une nouvelle liste option en vérifiant les littéraux qui apparaissent dans une clause : si c'est le littéral que l'on souhaite simplifier, la clause est supprimée (None), si c'est l'opposé, ce littéral est enlevé de la clause, et sinon, on le garde. filter_map applique cette fonction à l'ensemble des clauses et renvoie les clauses modifiées.
---

2. Pour l'implémentation de `unitaire`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ? (Par une
   fonction auxiliaire, on entend ici soit une fonction d'une
   bibliothèque, par exemple des fonctions comme `List.length`,
   `List.rev_append`, ou une fonction `aux_unitaire` que vous avez
   écrite vous-mêmes.) Expliquez en quelques phrases en français
   comment ces fonctions auxiliaires sont utilisées dans votre
   implémentation de la fonction `unitaire`.

Dans notre implémentation de la fonction unitaire, on a pas utilisé de fonctions auxiliaires externes comme celles de la bibliothèque OCaml. La fonction utilise uniquement une structure récursive pour parcourir la liste des clauses.

La logique repose sur une correspondance de motifs pour vérifier si une clause est unitaire. Pour chaque clause, on examine la première clause (hd) de la liste clauses. Si cette clause contient un seul élément, c'est-à-dire qu'elle correspond au motif [a], je renvoie ce littéral a. Si la clause n'est pas unitaire, on appelle récursivement la fonction unitaire sur le reste des clauses (tl).

Cette approche permet d'arrêter la recherche dès qu'une clause unitaire est trouvée, rendant ainsi la fonction efficace.

---

3. Pour l'implémentation de `pur`, quelles sont les fonctions
   auxiliaires que vous avez utilisées et/ou écrites ?  Expliquez en
   quelques phrases en français comment ces fonctions auxiliaires sont
   utilisées dans votre implémentation de la fonction `pur`.

Dans notre implémentation de la fonction pur, on utilise plusieurs fonctions auxiliaires. On crée d'abord une table de hachage avec Hashtbl.create pour stocker les littéraux rencontrés. Ensuite, avec List.iter, on parcourt chaque clause et chaque littéral, qu'on insère dans la table via Hashtbl.replace. Pour trouver un littéral pur, on utilise Hashtbl.fold, qui vérifie si un littéral n'a pas son opposé dans la table avec Hashtbl.mem. Si aucun littéral pur n'est trouvé, on lève une exception.
Résumé des fonctions auxiliaires utilisées :
    Hashtbl.create : Crée une table pour stocker les littéraux.
    List.iter : Parcourt chaque clause et chaque littéral.
    Hashtbl.replace : Insère les littéraux dans la table de hachage.
    Hashtbl.fold : Recherche un littéral pur en vérifiant si son opposé est présent.
    Hashtbl.mem : Vérifie la présence de l'opposé d'un littéral dans la table.
---

4. Donnez un exemple d'une formule pour laquelle les deux fonctions
   `solveur_split` et `solveur_dpll_rec` ont un comportement
   différent, et expliquez les différences entre ces deux fonctions.

Prenons la formule suivante :

(1 ∨ 2) ∧ (¬1 ∨ 3) ∧ (¬2)

Avec solveur_split :

    Cette fonction choisit toujours le premier littéral (ici 1), applique la simplification, et continue à chercher une solution. Si le choix de 1 conduit à une impasse, elle essaie -1.
    Par exemple, si elle choisit 1, les clauses simplifiées seraient être [[3] ; [-2]], et elle poursuit avec cette branche jusqu'à ce qu'une des branches aboutisse à une solution ou à une impasse.

Avec solveur_dpll_rec :

    Cette fonction recherche d'abord des littéraux unitaires. Dans cet exemple, après simplification initiale, elle pourrait trouver que la clause [-2] est une clause unitaire, ce qui signifie qu'elle doit être satisfaite par -2.
    Elle appliquerait alors -2 comme interprétation et simplifierait les clauses en conséquence, ce qui pourrait potentiellement conduire à une résolution différente.

    Pour conclure solveur_split choisit des littéraux de manière directe, tandis que solveur_dpll_rec exploite d'abord les littéraux unitaires, puis purs, ce qui lui permet de simplifier les clauses avant de procéder à des choix de littéraux. 
    Cette différence dans la stratégie de recherche peut amener solveur_dpll_rec à explorer différents chemins dans l'espace de recherche, potentiellement plus efficaces, en tirant parti des simplifications obtenues par les clauses unitaires et purs. 

---

5. Avez-vous d'autres remarques sur votre rendu ? (question optionnelle)

**à remplir**

---

--fin du fichier RENDU--